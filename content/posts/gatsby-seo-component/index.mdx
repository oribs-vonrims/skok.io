---
title: Gatsby SEO component
description: How to add Twitter, Open Graph, and Schema.org markup to Gatsby SEO component
datePublished: 2021-08-17
dateModified: 2021-08-17
image: ./cover.jpg
imageAlt: Husky doggo
hasIntro: true
---

import TableOfContents from "../../../src/components/TableOfContents"
import Intro from "../../../src/components/Intro"
import SeriesIntro from "../../components/gatsby-seo-series/series-intro"
import CompletedProjectedLinks from "../../components/gatsby-seo-series/completed-project-links"
import TwitterPlayground from "./components/twitter"
import OpenGraphPlayground from "./components/open-graph"
import SchemaPlayground from "./components/schema"
import ProjectTreePartThree from "./components/project-tree"

<Intro>

<SeriesIntro part="3" />

In part #3, we will create `SEO` component that will generate Twitter, Open Graph, and Schema.org meta tags
based on the page component its imported in. We will also cover tools for validating the markup.

<CompletedProjectedLinks />

Make yourself familiar with the folder structure and the files we will create in part 2:

<ProjectTreePartThree />

</Intro>

<TableOfContents
  items={props.tableOfContentsItems}
  ids={props.tableOfContentsHeaderIds}
/>

## SEO component

`SEO` component receives data from every page and acts as a wrapper for other smaller components. Based on the collected data it constructs `imageUrls`, `activePages`, and `url` objects and string that are passed down the components tree to `DefaultMeta`, `Twitter`, `OpenGraph`, and `SchemaOrg`.

```jsx fileName=src/components/SEO/index.js
import React from "react"
import DefaultMeta from "./DefaultMeta"
import OpenGraph from "./OpenGraph"
import Twitter from "./Twitter"
import SchemaOrg from "./SchemaOrg"
import useSiteMetadata from "../../hooks/useSiteMetadata"
import getActivePages from "./getActivePages"
import getImageUrls from "./getImageUrls"
import getCurrentUrl from "./getCurrentUrl"

const SEO = ({
  pathName,
  slug,
  title,
  description,
  images,
  imageAlt,
  pageId,
  type,
  breadcrumb,
  published,
  modified,
}) => {
  const {
    siteUrl,
    siteName,
    firstName,
    lastName,
    language,
    socialMedia,
    logo,
    address,
    speakableSelector,
    pages,
  } = useSiteMetadata()

  const imageUrls = getImageUrls({ images, siteUrl })
  const activePages = getActivePages({ pages, pageId })
  const url = getCurrentUrl({ siteUrl, pathName, slug, pages, activePages })

  const defaultMeta = {
    title,
    description,
    language,
    url,
  }

  const twitter = {
    title,
    description,
    imageUrls,
    imageAlt,
    socialMedia,
  }

  const openGraph = {
    siteName,
    firstName,
    lastName,
    title,
    description,
    imageUrls,
    imageAlt,
    modified,
    published,
    language,
    activePages,
    url,
  }

  const schemaOrg = {
    siteUrl,
    siteName,
    firstName,
    lastName,
    logo,
    language,
    socialMedia,
    address,
    speakableSelector,
    pathName,
    title,
    description,
    imageUrls,
    breadcrumb,
    type,
    modified,
    published,
    slug,
    pages,
    activePages,
    url,
  }

  return (
    <>
      <DefaultMeta {...defaultMeta} />
      <Twitter {...twitter} />
      <OpenGraph {...openGraph} />
      <SchemaOrg {...schemaOrg} />
    </>
  )
}

export default SEO
```

### getImageUrls helper function

After appling `ImageUrlFields` fragment on a File node we get back a deeply nested object with multiple relative paths. The purpose of `getImageUrls` function is to generate a URL for every path and pack it in a consice object.

```js fileName=src/components/SEO/getImageUrls.js
const getImageUrls = ({ images, siteUrl }) =>
  Object.entries(images).reduce((acc, image) => {
    const [
      key,
      {
        images: {
          fallback: { src: path },
        },
      },
    ] = image
    const url = `${siteUrl}${path}`
    acc[`${key}ImageUrl`] = url

    return acc
  }, {})

export default getImageUrls
```

### getActivePages helper function

Various page types require different markup templates. E.g. we need to generate [ContactPage](https://schema.org/ContactPage) schema for `/contact` page and [Article](https://schema.org/Article) schema for `/blog/pug/` page, but currently there is no way to distinguish between these two pages from inside of the `SEO` component.

`getActivePages` helper takes care of identifing the origin (page type) of the data it receives by checking `pageId` prop against a list of all pages defined in `site-metadata.js`. Later on we will rely on it's output to map pages with their corresponding templates.

```js fileName=src/components/SEO/getImageUrls.js
const getActivePages = ({ pages, pageId }) =>
  Object.entries(pages).reduce((acc, page) => {
    const [name, { id }] = page
    const firstLetter = name[0].toUpperCase()
    const remainingLetters = name.substr(1)
    const key = `is${firstLetter}${remainingLetters}`
    acc[key] = id === pageId

    return acc
  }, {})

export default getActivePages
```

### getCurrentUrl helper function

`getCurrentUrl` returns active URL based on the output from `getActivePages` helper.

```js fileName=src/components/SEO/getCurrentUrl.js
import slashify from "../../helpers/slashify"

const getCurrentUrl = ({
  siteUrl,
  pathName,
  slug,
  pages: {
    blog: { pathName: blogPathName },
  },
  activePages: { isHome, isArticle },
}) =>
  isHome
    ? siteUrl
    : isArticle
    ? slashify(siteUrl, blogPathName, slug)
    : slashify(siteUrl, pathName)

export default getCurrentUrl
```

### DefaultMeta component

Before adding `DefaultMeta` component we will need to install [`react-helmet`](https://github.com/nfl/react-helmet) and it's Gatsby plugin [`gatsby-plugin-react-helmet`](https://www.gatsbyjs.com/plugins/gatsby-plugin-react-helmet/):

```
yarn add react-helmet gatsby-plugin-react-helmet
```

And update `gatsby-config.js`:

```js fileName=gatsby-config.js
// ✂️
module.exports = {
  // ✂️
  plugins: [
    `gatsby-plugin-react-helmet`,
    // ✂️
  ],
}
```

`react-helmet` is a document head manager for React, and `gatsby-plugin-react-helmet` provides a drop-in support for server rendering data added with React Helmet.

```jsx fileName=src/components/SEO/DefaultMeta.js
import React from "react"
import Helmet from "react-helmet"

const DefaultMeta = ({ title, description, language, url }) => (
  <Helmet>
    <html lang={language} />
    <title>{title}</title>
    <meta name="description" content={description} />
    <link rel="canonical" href={url} />
  </Helmet>
)

export default DefaultMeta
```

`Helmet` component takes our HTML tags and renders them inside of the `head` tag.

### Twitter component

`Twitter` component contains twitter specific meta tags. When the URL on your blog we be shared in twitter it will be expanded it an attractive summary card with a large image.

<!-- Add screenshot of https://cards-dev.twitter.com/validator -->

```jsx fileName=src/components/SEO/Twitter.js
import React from "react"
import { Helmet } from "react-helmet"

const Twitter = ({
  title,
  description,
  imageUrls: { twitterImageUrl: image },
  imageAlt,
  socialMedia: { twitter: creator },
}) => (
  <Helmet>
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={image} />
    <meta name="twitter:image:alt" content={imageAlt} />
    <meta
      name="twitter:creator"
      content={new URL(creator).pathname.replace(`/`, `@`)}
    />
  </Helmet>
)

export default Twitter
```

- `twitter:card` is a type of card. We are using "Summary Large Image" that features a large, full-width prominent image alongside a tweet.
- `twitter:creator` is the person who wrote the content. It's value has to be a Twitter handle starting with `@` symbol.

To learn more about twitter cards check out their [documentation](https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/markup)

<TwitterPlayground />

### OpenGraph component

The Open Graph protocol is supported by a wide range of social media platforms that includes Facebook (it also created this protocol in 2010), LinkedIn, Pinterest, Twitter (when Twitter can't find twitter meta tags it will fall back into using Open Graph meta tags), and others. To learn more about it you can have a look at [Open Graph protocol documention](https://ogp.me/)

`OpenGraph` component conditionally renderes the given data based on the page type it is included in. This is when `activePages` object becomes handy.

```jsx fileName=src/components/SEO/OpenGraph.js
import React from "react"
import { Helmet } from "react-helmet"

const OpenGraph = ({
  siteName,
  firstName,
  lastName,
  title,
  description,
  imageUrls: { openGraphImageUrl: image },
  imageAlt,
  modified,
  published,
  language,
  activePages: { isArticle },
  url,
}) => (
  <Helmet>
    <meta property="og:type" content={isArticle ? `article` : `website`} />
    <meta property="og:url" content={url} />
    <meta property="og:site_name" content={siteName} />
    <meta property="og:locale" content={language} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={image} />
    <meta property="og:image:alt" content={imageAlt} />

    {isArticle && published && (
      <meta property="article:published_time" content={published} />
    )}
    {isArticle && modified && (
      <meta property="article:modified_time" content={modified} />
    )}
    {isArticle && (
      <meta property="article:author" content={`${firstName} ${lastName}`} />
    )}
  </Helmet>
)

export default OpenGraph
```

- `og:type` the type of object that is represented in Open Graph. It can be music, video, website, profile, article, and several others. We will be using article if it's included in the `Article` page component, and website for the rest of the pages.
- `og:url` is the canonical URL of the object.
- `og:locale` the language of the content. Defaults to `en_US`.

These tags will be rendered only in the `Article` template:

- `article:author` author of the article.
- `article:published_time` publish time of the article.
- `article:modified_time` modified time of the article.

<OpenGraphPlayground />

### What is Schema.org?

Schema.org is a structured data markup, which helps search engines interpret the content of web pages. It was initially launched in 2011 by Google, Yahoo, and Bing. Once added to a webpage it conveys the contextual meaning to search engines by using a hierarchical set of schemas.

<!-- Add schema hierarchicy image https://upload.wikimedia.org/wikipedia/commons/8/8e/Schema.org_%285925660995%29.png -->

HTML cannot provide a meaning of what a text string means. E.g. a webpage can include a header of `<h1>Apple</h1>` and it can refer to a fruit or a company. This is when schema.org comes into play and provides semantical meaning to search engines.

[Schema.org vocabulary](https://schema.org/docs/full.html) is extremely broad and in order to be practical we are going to focus on the schemas, that are officially supported by Google. This way we are going to help search engines as well as benefit from rich results (aka [rich snippets](https://developers.google.com/search/docs/guides/search-gallery) that are normal Google search results with additional data displayed). Rich snippets stand out from the other search results, look more appealing, and have a higher click-thru rate.

<!-- Add rich snippets example image -->

Before jumping into coding I want to make you familiar with the concept of node identifiers. To put it in simple words it's a unique `@id` property, that gets attached to a schema and then can be referenced inside of another schema. This is extremely useful for keeping the code DRY and readable.

Take a look at this example:

```html
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "PostalAddress",
    "@id": "https://example.com/#address",
    "addressCountry": "US",
    "addressLocality": "Los Angeles",
    "addressRegion": "CA"
  }
</script>
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Person",
    "@id": "https://example.com/#person",
    "name": "Jane Doe",
    "address": { "@id": "https://example.com/#address" }
  }
</script>
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@id": "https://example.com/#organization",
    "@type": "Organization",
    "url": "https://example.com",
    "name": "Gatsby SEO",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.com/logo.jpg",
      "height": 640,
      "width": 640
    },
    "address": { "@id": "https://example.com/#address" }
  }
</script>
```

In the above example we created `PostalAddress` schema and then referenced it inside of the `Person` and `Organization` schemas by passing its node identifier ID. If we don't use node identifiers we end up duplicating the whole `PostalAddress` object in `Person` and `Organization` schemas.

Node identifier value can be pretty much anything, but the common practice is to use the domain name and the hash with a schema type name https://example.com/#schema.

### SchemaOrg component

In `SchemaOrg` component we generate address, person, organization, breadcrumb, and page (`WebPage`, `Blog`, `ContactPage`, `AboutPage`, or `Article` schema based on the page type) schemas, link them together and compose into single JSON object.

```jsx fileName=src/components/SEO/SchemaOrg.js
import React from "react"
import Helmet from "react-helmet"
import slashify from "../../helpers/slashify"

const SchemaOrg = ({
  siteUrl,
  siteName,
  firstName,
  lastName,
  logo: { pathName: logoPathName, width: logoWidth, height: logoHeight },
  language,
  socialMedia: { twitter, github },
  address,
  speakableSelector,
  pathName,
  title,
  description,
  imageUrls: {
    schemaOrg1x1ImageUrl,
    schemaOrg4x3ImageUrl,
    schemaOrg16x9ImageUrl,
  },
  breadcrumb,
  type,
  modified,
  published,
  slug,
  pages: {
    home: { breadcrumb: homeBreadcrumb },
    blog: { breadcrumb: blogBreadcrumb, pathName: blogPathName },
  },
  activePages: { isHome, isBlog, isAbout, isContact, isArticle },
  url,
}) => {
  const schemaId = id => `${siteUrl}/#${id}`

  const fullName = `${firstName} ${lastName}`
  const pageUrl = slashify(siteUrl, pathName)
  const blogPageUrl = slashify(siteUrl, blogPathName)
  const articlePageUrl = slashify(siteUrl, blogPathName, slug)

  const schemaOrgAddress = {
    "@type": `PostalAddress`,
    "@id": schemaId(`address`),
    ...address,
  }

  const schemaOrgPerson = {
    "@type": `Person`,
    "@id": schemaId(`person`),
    url: siteUrl,
    name: fullName,
    sameAs: [twitter, github],
    address: {
      "@id": schemaId(`address`),
    },
  }

  const schemaOrgOrganization = {
    "@id": schemaId(`organization`),
    "@type": `Organization`,
    url: siteUrl,
    name: siteName,
    logo: {
      "@type": `ImageObject`,
      url: slashify(siteUrl, logoPathName),
      height: logoHeight,
      width: logoWidth,
    },
    address: {
      "@id": schemaId(`address`),
    },
  }

  const schemaOrgPage = Object.assign(
    {
      "@type": type,
      author: { "@id": schemaId(`person`) },
      publisher: { "@id": schemaId(`organization`) },
      description,
      headline: title,
      inLanguage: language,
      name: title,
      url,
      mainEntityOfPage: url,
      image: [
        schemaOrg1x1ImageUrl,
        schemaOrg4x3ImageUrl,
        schemaOrg16x9ImageUrl,
      ],
    },
    isArticle &&
      published && {
        datePublished: published,
      },
    isArticle && modified
      ? { dateModified: modified }
      : published
      ? { dateModified: published }
      : null,
    !isBlog &&
      speakableSelector && {
        speakable: {
          "@type": `SpeakableSpecification`,
          cssSelector: speakableSelector,
        },
      }
  )

  const breadcrumbList = [
    {
      id: siteUrl,
      name: homeBreadcrumb,
    },
  ]

  if (isBlog || isContact || isAbout) {
    breadcrumbList.push({
      id: pageUrl,
      name: breadcrumb,
    })
  } else if (isArticle) {
    breadcrumbList.push(
      {
        id: blogPageUrl,
        name: blogBreadcrumb,
      },
      {
        id: articlePageUrl,
        name: title,
      }
    )
  }

  const schemaOrgBreadcrumbs = {
    "@type": `BreadcrumbList`,
    "@id": schemaId(`breadcrumbs`),
    name: `Breadcrumbs`,
    itemListElement: breadcrumbList.map(({ id, name }, index) => ({
      "@type": `ListItem`,
      position: index + 1,
      name,
      item: {
        "@type": `WebPage`,
        "@id": id,
      },
    })),
  }

  const schemaOrg = {
    "@context": "http://schema.org",
    "@graph": [
      schemaOrgAddress,
      schemaOrgPerson,
      schemaOrgOrganization,
      schemaOrgPage,
    ],
  }

  if (!isHome) {
    schemaOrg["@graph"].push(schemaOrgBreadcrumbs)
  }

  return (
    <Helmet>
      <script type="application/ld+json">{JSON.stringify(schemaOrg)}</script>
    </Helmet>
  )
}

export default SchemaOrg
```

- `PostalAddress` consists of `country`, `locality`, and `region` fields
- `Person` consists of `name`, `url` (root URL), `sameAs` (list of social media profiles) and `address` (reference to the previously defined `PostalAddress` schema) fields
- `Organization` consists of `url`, `name`, `address` (reference to the `PostalAddress` schema), and `logo` fields

> Add `logo.jpg` image in `./static` directory. Every file you put into that folder will be
> copied into the public folder. E.g. if you add a file named `dog.jpg` to the static folder,
> it’ll be copied to `public/dog.jpg` and will be available at `https://<SITE_URL>/dog.jpg` URL.

Once we are done with smaller pieces we can start working on the generic page schema. It will generate `WebPage`, `Blog`, `ContactPage`, `AboutPage`, and `Article` schemas. Here is the list of properties that
are shared in all of the page schemas:

- `type`
- `name`
- `description`
- `author`
- `publisher`
- `headline`
- `inLanguage`
- `url`
- `mainEntityOfPage`
- `image`

The rest of the properties we will be added conditionally depending on the page type. For the article page it will be `datePublished`, and `dateModified`. And the blog page is the only schema that contains `speakable` field.

To conditionally add properties to the object we leverage `Object.assign` method. In order not to define `dateModified` that will be the same as `datePublished` in the frontmatter for every new blog post we check if `dateModified` exists and then apply it, otherwise, we reuse `datePublished` value (`datePublished` and `dateModified` are the required property on the `Article` schema).

`BreadcrumbList` schema is independent and doesn't appear to be a part of any other schema. It consists of a chain of linked web pages. The position property is used to order the items and starts with `1`. The very first item is always going to be the home page, that's the reason why we define `breadcrumbList` with `siteUrl` right away. The second level is a blog, contact, or about pages. The third level is an article and we know that it will always go after the blog page, that's why we push both of the values to the `breadcrumbList` array at once.

Once all the schemas are constructed we are creating a node array using `@graph` and fill it in with schemas. The only edge case is `BreadcrumbList` schema that shouldn't be added to the home page, so we are excluding it by checking `isHome`.

Each one of these schemas can contain other properties, so I will highly recommend to check [schema.org](https://schema.org/docs/full.html) documentation and tweak it for your own needs.

<SchemaPlayground />

## SEO Component Validation

To validate Twitter meta tags we will use [Twitter Card Validator](https://cards-dev.twitter.com/validator) tool made by Twitter (dah!). Make sure that you are testing production URLs, because this tool respects `robots.txt` settings (we will cover it in [part 4 of the series](/gatsby-sitemap-and-robots-txt-files)) and will not render a card if you `Disallow` bot access to your website.

For Open Graph validation you can use [Facebook Sharing Debugger](https://developers.facebook.com/tools/debug) (requires Facebook account). Facebook sharing debugger caches the scraped results, so don't worry if you don't see the latest changes. There is a "Scrape Again" button that you can click to scrape the latest changes.

Most likely after clicking debug button you will see a warning - "The following required properties are missing: `fb:app_id`".
Though don't worry. The `fb:app_id` meta tag is not required and it doesn’t do anything.

[Add me](https://yoast.com/help/fb-app-id-warnings/)

For schema.org markup validation I will recommend to use [Google Structured Data](https://search.google.com/structured-data/testing-tool) and [Google Structured Data](https://search.google.com/test/rich-results) in conjunction. In my experience there cases when Google Structured Data will not find certain issues with your markup while Google Structured Data does and vice versa.

And if you are feeling lazy and just want to stare at the beautiful social media cards you can use [opengraph.xyz](https://www.opengraph.xyz/) that will render Twitter, Facebook, LinkedIn, and Discord cards in the same view.
