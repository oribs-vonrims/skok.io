---
title: Gatsby SEO component
description: How to add Twitter, Open Graph, and Schema.org markup to Gatsby SEO component
datePublished: 2021-08-17
dateModified: 2021-08-17
image: ./cover.jpg
imageAlt: Husky doggo
---

import TableOfContents from "../../../src/components/TableOfContents"
import Intro from "../../../src/components/Intro"
import { Underline, BracketX } from "../../../src/components/Notation"
import {
  SeriesIntro,
  CompletedProjectedLinks,
} from "../../components/gatsby-seo-series"
import {
  TwitterPlayground,
  OpenGraphPlayground,
  SchemaPlayground,
  ProjectTreePartThree,
} from "./components"

<Intro>

<SeriesIntro part="3" />

In part #3, we will create an `SEO` component. It will render Twitter, Open Graph, and Schema.org meta tags.
Then will cover all the necessary tools for validating the markup.

<CompletedProjectedLinks />

Take a few moments to get familiar with the project structure.

<ProjectTreePartThree />

</Intro>

<TableOfContents
  items={props.tableOfContentsItems}
  ids={props.tableOfContentsHeaderIds}
/>

## SEO component

The `SEO` component receives data from every page and acts as a wrapper for other smaller components. Based on the
received data it constructs `imageUrls`, `activePages` objects, and `url` string that is passed down the
components tree to `DefaultMeta`, `Twitter`, `OpenGraph`, and `SchemaOrg`.

```jsx fileName=src/components/SEO/index.js
import React from "react"
import DefaultMeta from "./DefaultMeta"
import OpenGraph from "./OpenGraph"
import Twitter from "./Twitter"
import SchemaOrg from "./SchemaOrg"
import useSiteMetadata from "../../hooks/useSiteMetadata"
import getActivePages from "./getActivePages"
import getImageUrls from "./getImageUrls"
import getCurrentUrl from "./getCurrentUrl"

const SEO = ({
  pathName,
  slug,
  title,
  description,
  images,
  imageAlt,
  pageId,
  type,
  breadcrumb,
  published,
  modified,
}) => {
  const {
    siteUrl,
    siteName,
    firstName,
    lastName,
    language,
    socialMedia,
    logo,
    address,
    speakableSelector,
    pages,
  } = useSiteMetadata()

  const imageUrls = getImageUrls({ images, siteUrl })
  const activePages = getActivePages({ pages, pageId })
  const url = getCurrentUrl({
    siteUrl,
    pathName,
    slug,
    pages,
    activePages,
  })

  const defaultMeta = {
    title,
    description,
    language,
    url,
  }

  const twitter = {
    title,
    description,
    imageUrls,
    imageAlt,
    socialMedia,
  }

  const openGraph = {
    siteName,
    firstName,
    lastName,
    title,
    description,
    imageUrls,
    imageAlt,
    modified,
    published,
    language,
    activePages,
    url,
  }

  const schemaOrg = {
    siteUrl,
    siteName,
    firstName,
    lastName,
    logo,
    language,
    socialMedia,
    address,
    speakableSelector,
    pathName,
    title,
    description,
    imageUrls,
    breadcrumb,
    type,
    modified,
    published,
    slug,
    pages,
    activePages,
    url,
  }

  return (
    <>
      <DefaultMeta {...defaultMeta} />
      <Twitter {...twitter} />
      <OpenGraph {...openGraph} />
      <SchemaOrg {...schemaOrg} />
    </>
  )
}

export default SEO
```

### getImageUrls helper function

After applying [`ImageUrlFields` fragment](/blog/gatsby-graphql-fragments/#imageurlfields-graphql-fragment)
on a File node we get back a deeply nested object with multiple relative paths. The purpose of `getImageUrls`
function is to generate a URL for every path and pack it in a concise object.

```js fileName=src/components/SEO/getImageUrls.js
const getImageUrls = ({ images, siteUrl }) =>
  Object.entries(images).reduce((acc, image) => {
    const [
      key,
      {
        images: {
          fallback: { src: path },
        },
      },
    ] = image
    const url = `${siteUrl}${path}`
    acc[`${key}ImageUrl`] = url

    return acc
  }, {})

export default getImageUrls
```

### getActivePages helper function

All page types have different markup templates. E.g. `/contact` page corresponds to
[ContactPage](https://schema.org/ContactPage) schema and `/blog/pug/` page correspond to
[article](https://schema.org/Article) schema, but there is no mechanism within the `SEO`
component to distinguish between these two pages; thus, no way to know which template to use.

`getActivePages` helper takes care of identifying the page type of the received data. It does
that by checking for `pageId` prop against a list of all pages defined in
[`site-metadata.js`](/blog/gatsby-node-and-config-files/#site-metadata). Later on, we will rely
on it's output to map pages with their corresponding templates.

```js fileName=src/components/SEO/getActivePages.js id=get-active-pages-code-block
const getActivePages = ({ pages, pageId }) =>
  Object.entries(pages).reduce((acc, page) => {
    const [name, { id }] = page
    const firstLetter = name[0].toUpperCase()
    const remainingLetters = name.substr(1)
    const key = `is${firstLetter}${remainingLetters}`
    acc[key] = id === pageId

    return acc
  }, {})

export default getActivePages
```

### getCurrentUrl helper function

`getCurrentUrl` returns page URL based on the output from [`getActivePages` helper](/blog/gatsby-seo-component/#get-active-pages-code-block).

```js fileName=src/components/SEO/getCurrentUrl.js
import slashify from "../../helpers/slashify"

const getCurrentUrl = ({
  siteUrl,
  pathName,
  slug,
  pages: {
    blog: { pathName: blogPathName },
  },
  activePages: { isHome, isArticle },
}) =>
  isHome
    ? siteUrl
    : isArticle
    ? slashify(siteUrl, blogPathName, slug)
    : slashify(siteUrl, pathName)

export default getCurrentUrl
```

### DefaultMeta component

Before adding `DefaultMeta` component we will need to install [`react-helmet`](https://github.com/nfl/react-helmet) and
its corresponding Gatsby plugin [`gatsby-plugin-react-helmet`](https://www.gatsbyjs.com/plugins/gatsby-plugin-react-helmet/):

```
yarn add react-helmet gatsby-plugin-react-helmet
```

Update `gatsby-config.js`:

```js fileName=gatsby-config.js
// ✂️
module.exports = {
  // ✂️
  plugins: [
    `gatsby-plugin-react-helmet`,
    // ✂️
  ],
}
```

`react-helmet` is a document head manager for React, and `gatsby-plugin-react-helmet` provides a drop-in support
for server rendering data added with React Helmet.

```jsx fileName=src/components/SEO/DefaultMeta.js
import React from "react"
import Helmet from "react-helmet"

const DefaultMeta = ({ title, description, language, url }) => (
  <Helmet>
    <html lang={language} />
    <title>{title}</title>
    <meta name="description" content={description} />
    <link rel="canonical" href={url} />
  </Helmet>
)

export default DefaultMeta
```

`Helmet` component takes your HTML tags and renders them inside of the `head` tag.

### Twitter component

`Twitter` component contains twitter specific meta tags. When the URL on your blog
is shared via Twitter, it will be expanded in an attractive summary card with a large image.

```jsx fileName=src/components/SEO/Twitter.js
import React from "react"
import { Helmet } from "react-helmet"

const Twitter = ({
  title,
  description,
  imageUrls: { twitterImageUrl: image },
  imageAlt,
  socialMedia: { twitter: creator },
}) => (
  <Helmet>
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={image} />
    <meta name="twitter:image:alt" content={imageAlt} />
    <meta
      name="twitter:creator"
      content={new URL(creator).pathname.replace(`/`, `@`)}
    />
  </Helmet>
)

export default Twitter
```

- `twitter:card` is a type of card. We use "Summary Large Image" that features a large,
  full-width prominent image alongside a tweet.
- `twitter:creator` is the person who wrote the content. Its value has to be a Twitter
  handle starting with `@` symbol.

To learn more about Twitter cards, check out their [documentation](https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/markup).

<TwitterPlayground />

### OpenGraph component

The Open Graph protocol is supported by a wide range of social media platforms, including Facebook
(it also created this protocol in 2010), LinkedIn, Pinterest, and Twitter (when Twitter cant find Twitter
meta tags, it will fall back to using Open Graph), and others. To learn more about it, you can have a look at
[Open Graph protocol documention](https://ogp.me/).

`OpenGraph` component renderes markup based on the provided page type. This is when [`getActivePages`](/blog/gatsby-seo-component/#get-active-pages-code-block)
becomes handy.

```jsx fileName=src/components/SEO/OpenGraph.js
import React from "react"
import { Helmet } from "react-helmet"

const OpenGraph = ({
  siteName,
  firstName,
  lastName,
  title,
  description,
  imageUrls: { openGraphImageUrl: image },
  imageAlt,
  modified,
  published,
  language,
  activePages: { isArticle },
  url,
}) => (
  <Helmet>
    <meta property="og:type" content={isArticle ? `article` : `website`} />
    <meta property="og:url" content={url} />
    <meta property="og:site_name" content={siteName} />
    <meta property="og:locale" content={language} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={image} />
    <meta property="og:image:alt" content={imageAlt} />

    {isArticle && published && (
      <meta property="article:published_time" content={published} />
    )}
    {isArticle && modified && (
      <meta property="article:modified_time" content={modified} />
    )}
    {isArticle && (
      <meta property="article:author" content={`${firstName} ${lastName}`} />
    )}
  </Helmet>
)

export default OpenGraph
```

- `og:type` the type of object that is represented in Open Graph (can be music, video, website, profile, article,
  and others). Its going to be article if rendered inside of the [`Article` page component](/blog/gatsby-graphql-fragments/#article-page-component),
  and website for the rest of the pages
- `og:url` is the canonical URL of the object
- `og:locale` the language of the content (when not specified defaults to `en_US`)

These tags will be rendered only in the `Article` template:

- `article:author`
- `article:published_time`
- `article:modified_time`

<OpenGraphPlayground />

### What is Schema.org?

Schema.org is a structured data markup that helps search engines interpret the content of web pages. It was initially
launched in 2011 by Google, Yahoo, and Bing. Once added to a webpage, <Underline>it conveys the contextual meaning to search engines
by using a hierarchical set of schemas.</Underline>

HTML cannot provide a meaning of what a text string means. E.g., a webpage can include a header of `<h1>Apple</h1>`, and it
can refer to a fruit or a company. This is when schema.org comes into play and provides semantical meaning to search engines.

[Schema.org vocabulary](https://schema.org/docs/full.html) is vast, and to be practical, we will focus
only on the schemas that Google officially supports. This way, we are going to help search engines as well as
benefit from rich results (aka [rich snippets](https://developers.google.com/search/docs/guides/search-gallery) that
are normal Google search results with additional data displayed). Rich snippets stand out from the other search
results, look more appealing, and have a higher click-through rate.

![Screenshot of pizza recipies rich snippets](rich-snippets.png)

Before jumping straight to the code, I would like to explain what node identifiers are. It's a unique `@id` property
that gets attached to a schema and can be referenced inside another schema. This is extremely useful for
keeping the code DRY and readable.

Take a look at this example:

```html id=node-identifier-code-block
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "PostalAddress",
    "@id": "https://example.com/#address",
    "addressCountry": "US",
    "addressLocality": "Los Angeles",
    "addressRegion": "CA"
  }
</script>
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Person",
    "@id": "https://example.com/#person",
    "name": "Jane Doe",
    "address": {
      "@id": "https://example.com/#address"
    }
  }
</script>
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@id": "https://example.com/#organization",
    "@type": "Organization",
    "url": "https://example.com",
    "name": "Gatsby SEO",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.com/logo.jpg",
      "height": 640,
      "width": 640
    },
    "address": {
      "@id": "https://example.com/#address"
    }
  }
</script>
```

In the above example, we created `PostalAddress` schema and then referenced it inside of the `Person` and
`Organization` schemas by passing its node identifier ID. If we don't take advantage of node identifiers, we end up
duplicating the whole `PostalAddress` object inside the `Person` and `Organization` schemas.

Node identifier value can be pretty much anything, but the standard practice is to use the domain name and
the hash with a schema type name `https://example.com/#schema`.

### SchemaOrg component

In `SchemaOrg` component we generate address, person, organization, breadcrumb, and page (`WebPage`, `Blog`,
`ContactPage`, `AboutPage`, or `Article`) schemas, link them together using [node identifiers](/blog/gatsby-seo-component/#node-identifier-code-block)
and compose into a single JSON object.

```jsx fileName=src/components/SEO/SchemaOrg.js
import React from "react"
import Helmet from "react-helmet"
import slashify from "../../helpers/slashify"

const SchemaOrg = ({
  siteUrl,
  siteName,
  firstName,
  lastName,
  logo: { pathName: logoPathName, width: logoWidth, height: logoHeight },
  language,
  socialMedia: { twitter, github },
  address,
  speakableSelector,
  pathName,
  title,
  description,
  imageUrls: {
    schemaOrg1x1ImageUrl,
    schemaOrg4x3ImageUrl,
    schemaOrg16x9ImageUrl,
  },
  breadcrumb,
  type,
  modified,
  published,
  slug,
  pages: {
    home: { breadcrumb: homeBreadcrumb },
    blog: { breadcrumb: blogBreadcrumb, pathName: blogPathName },
  },
  activePages: { isHome, isBlog, isAbout, isContact, isArticle },
  url,
}) => {
  const schemaId = id => `${siteUrl}/#${id}`

  const fullName = `${firstName} ${lastName}`
  const pageUrl = slashify(siteUrl, pathName)
  const blogPageUrl = slashify(siteUrl, blogPathName)
  const articlePageUrl = slashify(siteUrl, blogPathName, slug)

  const schemaOrgAddress = {
    "@type": `PostalAddress`,
    "@id": schemaId(`address`),
    ...address,
  }

  const schemaOrgPerson = {
    "@type": `Person`,
    "@id": schemaId(`person`),
    url: siteUrl,
    name: fullName,
    sameAs: [twitter, github],
    address: {
      "@id": schemaId(`address`),
    },
  }

  const schemaOrgOrganization = {
    "@id": schemaId(`organization`),
    "@type": `Organization`,
    url: siteUrl,
    name: siteName,
    logo: {
      "@type": `ImageObject`,
      url: slashify(siteUrl, logoPathName),
      height: logoHeight,
      width: logoWidth,
    },
    address: {
      "@id": schemaId(`address`),
    },
  }

  const schemaOrgPage = Object.assign(
    {
      "@type": type,
      author: { "@id": schemaId(`person`) },
      publisher: { "@id": schemaId(`organization`) },
      description,
      headline: title,
      inLanguage: language,
      name: title,
      url,
      mainEntityOfPage: url,
      image: [
        schemaOrg1x1ImageUrl,
        schemaOrg4x3ImageUrl,
        schemaOrg16x9ImageUrl,
      ],
    },
    isArticle &&
      published && {
        datePublished: published,
      },
    isArticle && modified
      ? { dateModified: modified }
      : published
      ? { dateModified: published }
      : null,
    !isBlog &&
      speakableSelector && {
        speakable: {
          "@type": `SpeakableSpecification`,
          cssSelector: speakableSelector,
        },
      }
  )

  const breadcrumbList = [
    {
      id: siteUrl,
      name: homeBreadcrumb,
    },
  ]

  if (isBlog || isContact || isAbout) {
    breadcrumbList.push({
      id: pageUrl,
      name: breadcrumb,
    })
  } else if (isArticle) {
    breadcrumbList.push(
      {
        id: blogPageUrl,
        name: blogBreadcrumb,
      },
      {
        id: articlePageUrl,
        name: title,
      }
    )
  }

  const schemaOrgBreadcrumbs = {
    "@type": `BreadcrumbList`,
    "@id": schemaId(`breadcrumbs`),
    name: `Breadcrumbs`,
    itemListElement: breadcrumbList.map(({ id, name }, index) => ({
      "@type": `ListItem`,
      position: index + 1,
      name,
      item: {
        "@type": `WebPage`,
        "@id": id,
      },
    })),
  }

  const schemaOrg = {
    "@context": "http://schema.org",
    "@graph": [
      schemaOrgAddress,
      schemaOrgPerson,
      schemaOrgOrganization,
      schemaOrgPage,
    ],
  }

  if (!isHome) {
    schemaOrg["@graph"].push(schemaOrgBreadcrumbs)
  }

  return (
    <Helmet>
      <script type="application/ld+json">{JSON.stringify(schemaOrg)}</script>
    </Helmet>
  )
}

export default SchemaOrg
```

- `PostalAddress` consists of `country`, `locality`, and `region` fields
- `Person` consists of `name`, `url` (root URL), `sameAs` (list of social media profiles) and `address` fields
- `Organization` consists of `url`, `name`, `address` (reference to the `PostalAddress` schema), and `logo` fields

<BracketX>

Add `logo.jpg` image in `./static` directory. Every file you put into that folder will be
copied into the public folder. E.g., if you add a file named `dog.jpg` to the static folder,
it’ll be copied to `public/dog.jpg` and will be available at `https://<SITE_URL>/dog.jpg` URL.

</BracketX>

Once we are done with smaller pieces, we can move to the generic page schema. It will generate `WebPage`,
`Blog`, `ContactPage`, `AboutPage`, and `Article` schemas. Here is the list of properties that
are shared in all of these schemas:

- `type`
- `name`
- `description`
- `author`
- `publisher`
- `headline`
- `inLanguage`
- `url`
- `mainEntityOfPage`
- `image`

The rest of the properties will be added conditionally depending on the page type. Article schema requires
`datePublished`, and `dateModified` and blog schema contains `speakable` field.

To conditionally add properties to the object, we leverage `Object.assign` method. To avoid duplication of
`datePublished` value in `dateModified` for every new blog post we check if `dateModified` exists and then apply
it. Otherwise, we reuse `datePublished` value as `dateModified`.

`BreadcrumbList` schema doesn't appear to be a part of any other schema. It consists of a chain of linked web pages.
The position property is used to order the items and starts with `1`. The home page will always be the first item, that's
the reason why we define `breadcrumbList` with `siteUrl` right away. The second level is a blog, contact, or about page.
With our [URL structure](/blog/gatsby-graphql-fragments/#page-components-and-url-structure-overview), the third level will always
be an article and always go after the blog page. That's why we push both of these values to the `breadcrumbList`
array at once.

Once all the schemas are constructed, we create a node array using `@graph` and fill it in with schemas. The only
edge case we need to handle is `BreadcrumbList` on the home page. There is no reason to have to, so it needs to be excluded by
checking `isHome` variable.

Check out [Schema.org documentation](https://schema.org/docs/full.html) if you want to learn more about the schemas.

<SchemaPlayground />

## SEO Component Validation

To validate Twitter meta tags, use [Twitter Card Validator](https://cards-dev.twitter.com/validator) tool. Make sure
that you are testing production URLs, because this tool respects [`robots.txt` settings](/blog/gatsby-sitemap-and-robots-txt-files/#robotstxt).

![Screenshot of Twitter Card Validator tool](article-page-twitter-card-validator.png)

For Open Graph validation, use [Facebook Sharing Debugger](https://developers.facebook.com/tools/debug) (requires
Facebook account). Facebook sharing debugger caches the results, so if you don't see the latest changes, click
"Scrape Again" button to fetch the latest version of the page. After clicking the debug button, you will most likely see a
warning - "The following required properties are missing: `fb:app_id`". Though don't you worry. The `fb:app_id`
meta tag is not required, and it doesn’t do anything nowadays.

![Screenshot of Facebook Sharing Debugger tool](article-page-fb-sharing-debugger.png)

For schema.org validation, I recommend using [Google Rich Results](https://search.google.com/test/rich-results) and
[Schema.org Validator](https://validator.schema.org/) in conjunction. In my experience, there cases when
Google Rich Results will not find specific issues while Schema.org Validator will and vice versa.

![Screenshot of Google Rich Results tool](article-page-google-rich-results.png)
