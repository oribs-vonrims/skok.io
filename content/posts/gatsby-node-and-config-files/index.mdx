---
title: gatsby-config.js & gatsby-node.js files
description: How to setup the foundation for any Gatsby project
datePublished: 2021-08-15
dateModified: 2021-08-15
image: ./cover.jpg
imageAlt: Husky doggo
# Gatsby cant infer the type of optinal field automatically
# so we have to add it at lease once.
hasIntro: true
---

import TableOfContents from "../../../src/components/TableOfContents"
import Intro from "../../../src/components/Intro"
import {
  SeriesIntro,
  GraphiQLIframe,
  CompletedProjectedLinks,
} from "../../components/gatsby-seo-series"
import { ProjectTreePartOne, SlashifyTable } from "./components"

<Intro>

<SeriesIntro part="1" />

In part #1, we prepare the foundation for the whole project. Kicking it off with installing and configuring
plugins in `gatsby-config.js`. Then adding `useSiteMetadata` react hook for fetching data from `gatsby-config.js`.
After this we configure `gatsby-node.js` file that takes care of generating blog posts and pages from MDX files.
And lastly, learn about the dangers of inconsistant URL trailing slashes and how to deal with them.

<CompletedProjectedLinks />

Take a few moments to get familiar with the project structure (click on the folder to expand it).

<ProjectTreePartOne />

</Intro>

<TableOfContents
  items={props.tableOfContentsItems}
  ids={props.tableOfContentsHeaderIds}
/>

## Dependencies

First things first, install project dependencies.

```
yarn add \
  react \
  react-dom \
  gatsby \
  gatsby-source-filesystem \
  gatsby-plugin-sharp \
  gatsby-transformer-sharp \
  gatsby-plugin-image \
  theme-ui \
  gatsby-plugin-theme-ui \
  @mdx-js/mdx \
  @mdx-js/react \
  gatsby-plugin-mdx \
  dotenv
```

## Site Metadata

Add `./site-metadata.js` that will be a central place for storing all SEO-related data.

```js fileName=site-metadata.js
module.exports = {
  siteName: `Gatsby SEO`,
  firstName: `Jane`,
  lastName: `Doe`,
  logo: {
    pathName: `logo.jpg`,
    width: 640,
    height: 640,
  },
  language: `en_US`,
  socialMedia: {
    twitter: `https://twitter.com/gatsbyjs`,
    github: `https://github.com/gatsbyjs`,
  },
  address: {
    addressCountry: `US`,
    addressLocality: `Los Angeles`,
    addressRegion: `CA`,
  },
  speakableSelector: [`[data-speakable="true"]`],
  pages: {
    home: {
      id: `home`,
      pathName: `/`,
      title: `Jane Doe`,
      description: `Jane Doe's place on the web`,
      image: `./src/images/home.jpg`,
      imageAlt: `Two corgis sitting next to each other`,
      breadcrumb: `Home`,
      type: `WebPage`,
    },
    blog: {
      id: `blog`,
      pathName: `blog`,
      title: `Blog`,
      description: `Jane Doe's blog about software engineering`,
      image: `./src/images/blog.jpg`,
      imageAlt: `Cute brown Retriever is licking it's nose`,
      breadcrumb: `Blog`,
      type: `Blog`,
    },
    contact: {
      id: `contact`,
      pathName: `contact`,
      title: `Contact`,
      description: `Jane Doe's contact information`,
      image: `./src/images/contact.jpg`,
      imageAlt: `Bulldog is chilling on the ground`,
      breadcrumb: `Contact`,
      type: `ContactPage`,
    },
    about: {
      id: `about`,
      pathName: `about`,
      title: `About`,
      description: `Jane Doe's biography`,
      image: `./src/images/about.jpg`,
      imageAlt: `French bulldog is hanging out on the playground`,
      breadcrumb: `About`,
      type: `AboutPage`,
    },
    article: {
      id: `article`,
      type: `Article`,
    },
  },
}
```

- `speakableSelector` tells search engines and other assistive technologies that a particular section of the page is "[speakable](https://developers.google.com/search/docs/data-types/speakable)"
- `pathName` URL pathname. Trailing slash (`/`) is not included
- `breadcrumb` title that will be displayed in search engine results page aka SERP
- `image` relative path to the page cover image
- `imageAlt` text description for the cover image
- `language` the language of your content. Follows `<language>_<TERRITORY>` format
- `type` schema.org page type (this topic will be covered in [Gatsby SEO component](/blog/gatsby-seo-component/#what-is-schemaorg) part of the series)

Replace all the values with your own information. Create `static` folder in the root of the project and
add desired logo image `logo.jpg` to it.

## `gatsby-config.js`

`gatsby-config.js` file defines site's metadata, plugins, and other general configuration.

```js fileName=gatsby-config.js
const path = require("path")
const siteMetadata = require("./site-metadata")

require("dotenv").config({
  path: `.env.${process.env.NODE_ENV}`,
})

const {
  NODE_ENV,
  SITE_URL,
  URL: NETLIFY_SITE_URL = SITE_URL,
  DEPLOY_PRIME_URL: NETLIFY_DEPLOY_URL = NETLIFY_SITE_URL,
  CONTEXT: NETLIFY_ENV = NODE_ENV,
} = process.env
const isNetlifyProduction = NETLIFY_ENV === `production`
const siteUrl = isNetlifyProduction ? NETLIFY_SITE_URL : NETLIFY_DEPLOY_URL

module.exports = {
  siteMetadata: {
    ...siteMetadata,
    siteUrl,
  },
  plugins: [
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `images`,
        path: path.resolve(`./src/images`),
      },
    },
    {
      resolve: `gatsby-source-filesystem`,
      options: {
        name: `articles`,
        path: path.resolve(`./articles`),
      },
    },
    {
      resolve: `gatsby-plugin-sharp`,
      options: {
        useMozJpeg: true,
        defaultQuality: 100,
      },
    },
    `gatsby-transformer-sharp`,
    `gatsby-plugin-image`,
    `gatsby-plugin-mdx`,
    `gatsby-plugin-theme-ui`,
  ],
}
```

To keep `gatsby-config.js` file concise we moved SEO related data in a separate
file `site-metadata.js`. Now its time to import and spread it's content under `siteMetadata` key.

Import `path` and `dotenv` packages. Based on the `NODE_ENV` we will swap `siteUrl` value.
Create `.env.development` and `.env.production` files with `SITE_URL` of `http://localhost:8000`
and `https://<YOUR_PRODUCTION_URL>` in the root of the project.

```js fileName=gatsby-config.js
// ✂️
const {
  NODE_ENV,
  SITE_URL,
  URL: NETLIFY_SITE_URL = SITE_URL,
  DEPLOY_PRIME_URL: NETLIFY_DEPLOY_URL = NETLIFY_SITE_URL,
  CONTEXT: NETLIFY_ENV = NODE_ENV,
} = process.env
const isNetlifyProduction = NETLIFY_ENV === `production`
const siteUrl = isNetlifyProduction ? NETLIFY_SITE_URL : NETLIFY_DEPLOY_URL
// ✂️
```

The above code is required for Netlify deployments. It's going to replace
`siteUrl` value with Netlify URLs, that are autogenerated on PR preview or
branch deployments. You can read more about Netlify Deploy URLs and environment
variables in their [documentation](https://docs.netlify.com/configure-builds/environment-variables/#deploy-urls-and-metadata).

- [gatsby-source-filesystem](https://www.gatsbyjs.com/plugins/gatsby-source-filesystem/) plugin is used to source data from local filesystem. We configured it to access `./articles` and `./images` directories.
- [gatsby-plugin-sharp](https://www.gatsbyjs.com/plugins/gatsby-plugin-sharp/) exposes image processing functions of Sharp. Its Node.js image processing package for resizing JPEG, PNG, WebP, AVIF and TIFF images.
- [gatsby-transformer-sharp](https://www.gatsbyjs.com/plugins/gatsby-transformer-sharp/) creates `ImageSharp` nodes from images that are supported by the Sharp library and provides GraphQL fields for resizing, cropping, and creating responsive images.
- [gatsby-plugin-image](https://www.gatsbyjs.com/plugins/gatsby-plugin-image/) produces responsive images in multiple sizes and formats.
- [gatsby-plugin-mdx](https://www.gatsbyjs.com/plugins/gatsby-plugin-mdx/) adds MDX support.
- [gatsby-plugin-theme-ui](https://theme-ui.com/packages/gatsby-plugin/) adds Theme UI support (library for creating themeable user interfaces based on constraint-based design principles).

## useSiteMetadata hook

All SEO data is defined in `site-metadata.js` and now we need a conviniet way to retrieve it from React components.
For this purpose Gatsby has `useStaticQuery` hook that takes a GraphQL query and returns back the data.

Create `useSiteMetadata.js` in `./src/hooks` directory:

```js fileName=src/hooks/useSiteMetadata.js
import { useStaticQuery, graphql } from "gatsby"

const useSiteMetadata = () => {
  const {
    site: { siteMetadata },
  } = useStaticQuery(
    graphql`
      query {
        site {
          siteMetadata {
            siteUrl
            siteName
            firstName
            lastName
            logo {
              pathName
              width
              height
            }
            language
            socialMedia {
              twitter
              github
            }
            address {
              addressCountry
              addressLocality
              addressRegion
            }
            speakableSelector
            pages {
              home {
                id
                pathName
                title
                description
                imageAlt
                breadcrumb
                type
              }
              blog {
                id
                pathName
                title
                description
                imageAlt
                breadcrumb
                type
              }
              contact {
                id
                pathName
                title
                description
                imageAlt
                breadcrumb
                type
              }
              about {
                id
                pathName
                title
                description
                imageAlt
                breadcrumb
                type
              }
              article {
                id
                type
              }
            }
          }
        }
      }
    `
  )

  return siteMetadata
}

export default useSiteMetadata
```

`useSiteMetadata` hook can be used in every react component like so:

```jsx
const Welcome = () => {
  const { firstName } = useSiteMetadata()
  return <h1>Hello! My name is {firstName}</h1>
}
```

<GraphiQLIframe
  title="SiteMetadata GraphQL query example"
  query="query%20SiteMetadata%20%7B%0A%20%20site%20%7B%0A%20%20%20%20siteMetadata%20%7B%0A%20%20%20%20%20%20siteUrl%0A%20%20%20%20%20%20siteName%0A%20%20%20%20%20%20firstName%0A%20%20%20%20%20%20lastName%0A%20%20%20%20%20%20logo%20%7B%0A%20%20%20%20%20%20%20%20pathName%0A%20%20%20%20%20%20%20%20width%0A%20%20%20%20%20%20%20%20height%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20language%0A%20%20%20%20%20%20socialMedia%20%7B%0A%20%20%20%20%20%20%20%20twitter%0A%20%20%20%20%20%20%20%20github%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20address%20%7B%0A%20%20%20%20%20%20%20%20addressCountry%0A%20%20%20%20%20%20%20%20addressLocality%0A%20%20%20%20%20%20%20%20addressRegion%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20speakableSelector%0A%20%20%20%20%20%20pages%20%7B%0A%20%20%20%20%20%20%20%20home%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%0A%20%20%20%20%20%20%20%20%20%20pathName%0A%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20description%0A%20%20%20%20%20%20%20%20%20%20imageAlt%0A%20%20%20%20%20%20%20%20%20%20breadcrumb%0A%20%20%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20blog%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%0A%20%20%20%20%20%20%20%20%20%20pathName%0A%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20description%0A%20%20%20%20%20%20%20%20%20%20imageAlt%0A%20%20%20%20%20%20%20%20%20%20breadcrumb%0A%20%20%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20contact%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%0A%20%20%20%20%20%20%20%20%20%20pathName%0A%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20description%0A%20%20%20%20%20%20%20%20%20%20imageAlt%0A%20%20%20%20%20%20%20%20%20%20breadcrumb%0A%20%20%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20about%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%0A%20%20%20%20%20%20%20%20%20%20pathName%0A%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20description%0A%20%20%20%20%20%20%20%20%20%20imageAlt%0A%20%20%20%20%20%20%20%20%20%20breadcrumb%0A%20%20%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20article%20%7B%0A%20%20%20%20%20%20%20%20%20%20id%0A%20%20%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A&operationName=SiteMetadata"
/>

## gatsby-node.js

Gatsby exposes multiple NodeJS APIs that are accessible from `gatsby-node.js`. Code from
`gatsby-node.js` is execute only once during the build of the site.

`gatsby-node.js` will do three things for us:

1. Generate slugs for article pages based on the MDX file paths.
2. Dynamically create article pages from MDX files.
3. Pass absolute image paths from `siteMetadata` to page components. This will allow us to
   use GraphQL to crop images in [Gatsby GraphQL Fragments](/blog/gatsby-graphql-fragments/#imageurlfields-graphql-fragment)
   part of the series.

```js fileName=gatsby-node.js
const path = require("path")
const { createFilePath } = require("gatsby-source-filesystem")
const { pages } = require("./site-metadata")
const slashify = require("./src/helpers/slashify")

exports.onCreateNode = ({ node, getNode, actions: { createNodeField } }) => {
  if (node.internal.type === `Mdx`) {
    const value = createFilePath({ node, getNode }).replace(/\//g, ``)

    createNodeField({
      name: `slug`,
      value,
      node,
    })
  }
}

exports.createPages = ({ actions: { createPage }, graphql }) =>
  graphql(`
    query {
      allMdx {
        edges {
          node {
            id
            fields {
              slug
            }
          }
        }
      }
    }
  `).then(({ data, errors }) => {
    if (errors) Promise.reject(errors)

    data.allMdx.edges.forEach(
      ({
        node: {
          id,
          fields: { slug },
        },
      }) => {
        createPage({
          path: slashify(pages.blog.pathName, slug),
          component: path.resolve(`src/templates/article.jsx`),
          context: { id, slug },
        })
      }
    )
  })

exports.onCreatePage = ({ page, actions: { createPage, deletePage } }) => {
  const pagesMetadata = Object.values(pages)
    .map(({ pathName, image }) => [slashify(pathName), image])
    .filter(([pathName, image]) => pathName && image)

  pagesMetadata.forEach(([pathName, image]) => {
    if (page.path === pathName) {
      deletePage(page)
      createPage({
        ...page,
        context: {
          image: path.join(process.cwd(), image),
        },
      })
    }
  })
}
```

### onCreateNode API

[onCreateNode](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/#onCreateNode) is
called when a new node is created. We start with filtering out all `Mdx` nodes.
[createFilePath](https://www.gatsbyjs.com/plugins/gatsby-source-filesystem/#createfilepath) retrieves
file path from the node and then we purge it from redundant slashes (`/`). [createNodeField](https://www.gatsbyjs.com/docs/reference/config-files/actions/#createNodeField)
lets us extends current MDX node with a `slug` field.

### createPages API

With [createPages](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/#createPages) API we generate
article pages. The rest of the pages will be generated automatically by Gatsby, because they are located in
`src/pages` directory.

Gatsby API exposes a collection of actions that can be extracted via object destructuring. To generate articles
we first need to query for `slug` and `id` from every MDX node. Then we loop over each item in the `data` array
and call `createPage` with:

- `path` is a relative path starting with a forward slash e.g. `/blog/pug/`
  ([slashify helper function](/blog/gatsby-node-and-config-files/#slashify-code-block) takes care of formatting)
- `component` absolute path of the article component
- `context` extra data that will be accessible as `pageContext` prop in article component as well as an argument in
  graphql query.

<GraphiQLIframe
  title="AllMdx GraphiQL query example"
  query="query%20AllMdx%20%7B%0A%20%20allMdx%20%7B%0A%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20id%0A%20%20%20%20%20%20%20%20fields%20%7B%0A%20%20%20%20%20%20%20%20%20%20slug%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A&operationName=AllMdx&explorerIsOpen=false"
/>

### onCreatePage API

[onCreatePage](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/#onCreatePage) is a hook thats called when
a new page is created. As I mentioned before Gatsby will automatically create pages for the components
located in `./src/pages`, so in order to modify their context we will have to delete the originally generated page
and create it again by passing extra data.

To make it happen we destructure `page` (object that contains original page data), `createPage`, and `deletePage`
functions from the `actions`. Then we create `pagesMetadata` which is an array of tuples from `siteMetadata.pages`
that contains of `pathName` and `image`. After that we loop over all of the tuples and check if the current page
path matches one of the `pagesMetadata` paths. When it matches we delete this page and re-create it again with
`page` data and `context` that contains an absolute image path from `siteMetadata.pages`.

## URL Trailing Slashes

A trailing slash is a forward slash `/` placed at the end of a URL. The trailing slash is used to distinguish a
directory `/blog/` from a file `/blog/index.html`. This is a standard behavior of a web-server, but depending on
the web server it can handle trailing slashes differently. To enforce this behavior in Netlify make sure that
[Pretty URLs](https://docs.netlify.com/routing/redirects/redirect-options/#trailing-slash) option is enabled.

Inconsistent trailing slashes means that you are able to access a version of a page like `/blog/` and `/blog`
without being redirected. Google treats these pages as two different instances and can penalize your site for
duplicate content.

To address this problem we are going to add `./src/helpers/slashify.js`. This function will be used to format
all URLs, file paths or pathnames.

`slashify` has to take any number of arguments and it needs a way to identify a difference between a URL,
a pathname and a file pathname.

```js fileName=src/helpers/slashify.js id=slashify-code-block
const isHttpUrl = str => {
  try {
    return new URL(str) && Boolean(str.match(/http(s?):\/\//))
  } catch (_error) {
    return false
  }
}

const isFilePathName = str => str?.split(`.`).filter(Boolean).length > 1

const slashify = (...items) => {
  const length = items.length

  if (length === 1) {
    const item = items[0]
    if (item === `/`) {
      return `/`
    }

    if (isHttpUrl(item)) {
      return item
    }

    if (isFilePathName(item)) {
      return `/${item}`
    }

    return `/${item}/`
  } else {
    return items.reduce((acc, item, index) => {
      if (isHttpUrl(item)) {
        if (index !== 0) {
          throw Error(`HTTP URL has to be passed as the first argument`)
        } else {
          return item + `/`
        }
      }

      if (isFilePathName(item)) {
        if (index !== length - 1) {
          throw Error(`File pathname has to be passed as the last argument`)
        } else {
          return acc + item
        }
      }

      if (index === 0) {
        return `/${item}/`
      } else {
        return acc + item + `/`
      }
    }, ``)
  }
}

module.exports = slashify
```

To verify that a string is a valid URL we will leverage [URL constructor](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).

```js fileName=src/helpers/slashify.js
const isHttpUrl = str => {
  try {
    return new URL(str) && Boolean(str.match(/http(s?):\/\//))
  } catch (_error) {
    return false
  }
}
```

> [Optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) operator that
> is used in `isFilePathName` function is supported in NodeJS 14 and above. At the time of publishing this post Netlify's
> default NodeJS version is 12. The easiest way to bump Netlify's NodeJS version is to create `.nvmrc` file with the desired
> version at the root of the project.
>
> ```
> echo "16.3.0" > .nvmrc
> ```

- `isHttpUrl` takes a string that is passed in the URL constructor. When the string is not a valid URL
  the constructor will throw an error and will be caught in the `catch` block. `.match` makes sure that
  the URL starts with `http` or `https` as well as it includes `//`.
- `isFilePathName` is used to validate a file pathname. `str?` handles `undefined` values. `.filter(Boolean)`
  makes sure that the pathname does not end with a (`.`).

Usage examples:

<SlashifyTable />
